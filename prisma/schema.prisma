// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Optional pgvector extension for vector fields
  // extensions = ["pgvector"]
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  role          UserRole  @default(FAN)
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  // MVP Relations
  creator        Creator?
  fanProfile     FanProfile?
  subscriptions  Subscription[]  @relation("SubscriptionFan")
  sentMessages   Message[]       @relation("MessageSender")
  tips           Tip[]
  purchases      Purchase[]
  notifications  Notification[]
  auditLogs      AuditLog[]

  @@index([email])
  @@map("users")
}

model Creator {
  id               String          @id @default(cuid())
  userId           String          @unique
  handle           String          @unique
  displayName      String
  bio              String?
  avatarUrl        String?
  kycStatus        KycStatus       @default(PENDING)
  stripeAccountId  String?
  defaultPersonaId String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // Relations
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionTiers SubscriptionTier[]
  subscriptions     Subscription[]      @relation("SubscriptionCreator")
  chats             Chat[]
  personas          Persona[]
  memories          Memory[]
  tips              Tip[]
  content           Content[]
  purchases         Purchase[]
  payments          Payment[]
  kycVerifications  KycVerification[]
  defaultPersona    Persona?            @relation("DefaultPersona", fields: [defaultPersonaId], references: [id])

  @@index([handle])
  @@index([userId])
  @@map("creators")
}

model FanProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  displayName String?
  avatarUrl   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("fan_profiles")
}

model SubscriptionTier {
  id          String   @id @default(cuid())
  creatorId   String
  name        String
  priceCents  Int
  interval    String   @default("month")
  benefits    String[] // Array of benefit strings
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  creator       Creator        @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]

  @@index([creatorId])
  @@map("subscription_tiers")
}

model Subscription {
  id                     String            @id @default(cuid())
  fanId                  String
  creatorId              String
  tierId                 String
  stripeCustomerId       String?
  stripeSubscriptionId   String?           @unique
  status                 SubscriptionStatus
  currentPeriodEnd       DateTime?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt

  // Relations
  fan     User             @relation("SubscriptionFan", fields: [fanId], references: [id], onDelete: Cascade)
  creator Creator          @relation("SubscriptionCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  tier    SubscriptionTier @relation(fields: [tierId], references: [id], onDelete: Cascade)

  @@index([fanId])
  @@index([creatorId])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

model Chat {
  id        String   @id @default(cuid())
  creatorId String
  fanId     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  creator  Creator   @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  fan      User      @relation(fields: [fanId], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([creatorId, fanId])
  @@index([creatorId])
  @@index([fanId])
  @@map("chats")
}

model Message {
  id       String        @id @default(cuid())
  chatId   String
  senderId String
  sender   MessageSender
  text     String?
  mediaUrl String?
  createdAt DateTime     @default(now())

  // Relations
  chat       Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  senderUser User @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([senderId])
  @@map("messages")
}

model Persona {
  id              String   @id @default(cuid())
  creatorId       String
  name            String
  systemPrompt    String
  temperature     Float    @default(0.7)
  modelProvider   AIProvider @default(OPENAI)
  modelName       String   @default("gpt-4o-mini")
  embeddingModel  String   @default("text-embedding-3-small")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  creator           Creator   @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  defaultForCreator Creator[] @relation("DefaultPersona")

  @@index([creatorId])
  @@map("personas")
}

model Memory {
  id          String     @id @default(cuid())
  creatorId   String
  kind        MemoryKind
  // vector      Unsupported("vector(1536)")? // pgvector field if available
  externalRef String? // Fallback for external vector storage
  content     String
  createdAt   DateTime   @default(now())

  // Relations
  creator Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@index([kind])
  @@map("memories")
}

model Payment {
  id                  String        @id @default(cuid())
  type                PaymentType
  amountCents         Int
  stripePaymentIntentId String?     @unique
  applicationFeeCents Int
  creatorTransferId   String?
  status              PaymentStatus
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  // Relations (polymorphic)
  creatorId String
  creator   Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@index([stripePaymentIntentId])
  @@map("payments")
}

model Tip {
  id                    String   @id @default(cuid())
  fanId                 String
  creatorId             String
  amountCents           Int
  stripePaymentIntentId String?  @unique
  createdAt             DateTime @default(now())

  // Relations
  fan     User    @relation(fields: [fanId], references: [id], onDelete: Cascade)
  creator Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([fanId])
  @@index([creatorId])
  @@map("tips")
}

model Content {
  id          String           @id @default(cuid())
  creatorId   String
  title       String
  description String?
  mediaKey    String? // S3 key
  mediaType   String?
  visibility  ContentVisibility
  priceCents  Int?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  creator   Creator    @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  purchases Purchase[]

  @@index([creatorId])
  @@index([visibility])
  @@map("content")
}

model Purchase {
  id                    String   @id @default(cuid())
  fanId                 String
  contentId             String
  amountCents           Int
  stripePaymentIntentId String?  @unique
  createdAt             DateTime @default(now())

  // Relations
  fan     User    @relation(fields: [fanId], references: [id], onDelete: Cascade)
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  creator Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  creatorId String

  @@index([fanId])
  @@index([contentId])
  @@map("purchases")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  payload   Json
  readAt    DateTime?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([readAt])
  @@map("notifications")
}

model WebhookEvent {
  id          String    @id @default(cuid())
  provider    String    // STRIPE, etc.
  eventId     String    @unique
  payload     Json
  processedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([provider])
  @@index([eventId])
  @@map("webhook_events")
}

model KycVerification {
  id          String        @id @default(cuid())
  creatorId   String
  status      KycStatus
  provider    KycProvider   @default(STRIPE_IDENTITY)
  referenceId String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  creator Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@map("kyc_verifications")
}

model AuditLog {
  id           String   @id @default(cuid())
  actorUserId  String?
  action       String
  target       String
  metadata     Json
  createdAt    DateTime @default(now())

  // Relations
  actor User? @relation(fields: [actorUserId], references: [id])

  @@index([actorUserId])
  @@index([action])
  @@map("audit_logs")
}

// NextAuth.js models (preserved from existing)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// Enums
enum UserRole {
  FAN
  CREATOR
  ADMIN
}

enum KycStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum MessageSender {
  FAN
  CREATOR
  AI
}

enum AIProvider {
  OPENAI
  ANTHROPIC
}

enum MemoryKind {
  PROFILE
  LONG_TERM
  CONVERSATION_SUMMARY
}

enum PaymentType {
  SUBSCRIPTION
  TIP
  PPV
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ContentVisibility {
  FREE
  SUBSCRIBER
  PPV
}

enum KycProvider {
  STRIPE_IDENTITY
  MANUAL
}